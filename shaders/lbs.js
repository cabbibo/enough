var loadBarShader =  {
  vs:"\n\n\n    uniform mat4 iModelMat;\n\n    attribute vec3 tangent;\n    attribute float faceType;\n\n    // TODO: can we compute this in cpu?\n    varying mat3 vINormMat;\n\n    varying vec3 vNorm;\n    varying vec3 vTang;\n    varying vec3 vBino;\n    varying vec2 vUv;\n\n    varying vec3 vEye;\n    varying vec3 vMPos;\n    varying vec3 vPos;\n\n    varying float vFaceType;\n\n    mat3 matInverse( mat3 m ){\n    \n  \n    vec3 a = vec3(\n      \n        m[1][1] * m[2][2] - m[2][1] * m[1][2],\n        m[0][2] * m[2][1] - m[2][2] * m[0][1],\n        m[0][1] * m[1][2] - m[1][1] * m[0][2]\n        \n    );\n    \n    vec3 b = vec3(\n      \n        m[1][2] * m[2][0] - m[2][2] * m[1][0],\n        m[0][0] * m[2][2] - m[2][0] * m[0][2],\n        m[0][2] * m[1][0] - m[1][2] * m[0][0]\n        \n    );\n    \n     vec3 c = vec3(\n      \n        m[1][0] * m[2][1] - m[2][0] * m[1][1],\n        m[0][1] * m[2][0] - m[2][1] * m[0][0],\n        m[0][0] * m[1][1] - m[1][0] * m[0][1]\n        \n    );\n    \n    \n    return mat3( \n        \n       a.x , a.y , a.z ,\n       b.x , b.y , b.z ,\n       c.x , c.y , c.z\n        \n    );\n    \n \n  \n    \n}\n\n\n    void main(){\n\n      vFaceType = faceType;\n\n      vec3 pos = position;\n      vUv = uv;\n      vNorm = normalMatrix * normal;\n      \n      vMPos = ( modelMatrix * vec4( pos , 1. ) ).xyz;\n      //vMPos = pos.xyz;\n\n      vNorm = normal;\n      vTang = tangent;\n\n      vBino = cross( vNorm , vTang );\n\n      mat3 normMat = mat3(\n        vNorm.x , vNorm.y , vNorm.z ,\n        vTang.x , vTang.y , vTang.z ,\n        vBino.x , vBino.y , vBino.z \n      );\n\n      //normMat = normalMatrix * normMat;\n      vINormMat = matInverse( normMat );\n\n      vec3 iCamPos = ( iModelMat * vec4( cameraPosition , 1. ) ).xyz;\n      vEye = iCamPos - pos;\n      vPos = pos;\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( pos , 1. );\n\n\n    }\n\n  ", fs:"\n\n  vec3 hsv(float h, float s, float v){\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n  }\n\n\n  // Taken from https://www.shadertoy.com/view/4ts3z2\n  float tri(in float x){return abs(fract(x)-.5);}\n  vec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                   \n\n  // Taken from https://www.shadertoy.com/view/4ts3z2\n  float triNoise3D(in vec3 p, in float spd , in float time){\n    \n    float z=1.4;\n    float rz = 0.;\n    vec3 bp = p;\n\n    for (float i=0.; i<=3.; i++ ){\n     \n      vec3 dg = tri3(bp*2.);\n      p += (dg+time*.1*spd);\n\n      bp *= 1.8;\n      z *= 1.5;\n      p *= 1.2; \n        \n      rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n      bp += 0.14;\n\n    }\n\n    return rz;\n\n  }\n\nuniform float stepDepth;\nuniform float oscillationSize;\nuniform float time;\nuniform float brightness;\nuniform float noiseSize;\nuniform float transparency;\nuniform vec3 lightPos;\n\n\nvarying float vFaceType;\n\nvarying vec3 vNorm;\n\nvarying vec2 vUv;\n\nvarying vec3 vEye;\nvarying vec3 vMPos;\nvarying vec3 vPos;\n\nvarying mat3 vINormMat;\n\n#define STEPS 2\nvec4 volumeColor( vec3 ro , vec3 rd  , mat3 iBasis){\n\n  vec3 col = vec3( 0. );\n  float lum = 0.;\n  for( int i = 0; i < STEPS; i++ ){\n\n    vec3 p = ro - rd * float( i ) * stepDepth*5.;\n    \n    lum += pow(triNoise3D( p * .002 * noiseSize , float( i ) / float( STEPS ), time * .01),.3);//lu / 5.;\n\n    col += hsv( lum * 2. + sin( time * .1 ) , .4 , .4 );\n\n  } \n\n  return vec4( col , lum ) / float( STEPS );\n\n\n}\n\nvoid main(){\n\n\n  vec3 col =vec3(1.);// vTang * .5 + .5;\n  float alpha = 1.;\n\n  vec3 lightDir = normalize( lightPos - vMPos );\n  vec3 reflDir = reflect( lightDir , vNorm );\n  \n  float lambMatch =  -dot(lightDir ,  vNorm );\n  float reflMatch = max( 0. , -dot(normalize(reflDir) ,  normalize(vEye)) );\n\n  reflMatch = pow( reflMatch , 2. );\n\n  vec4 volCol = volumeColor( vPos , normalize(vEye) , vINormMat );\n\n  vec3 lambCol = lambMatch * volCol.xyz;\n  vec3 reflCol = reflMatch * (vec3(1.) - volCol.xyz);\n\n  col = volCol.xyz;// * lambMatch  + vec3(1. ) * (1.-lambMatch ) ;\n\n  float size = .04;\n  if( vUv.y > 1. - size  ){\n    col *= 2.;// lambCol * 3.;\n  }\n\n  gl_FragColor = vec4(  col *2. * brightness ,  transparency  );\n\n}\n\n\n  ", vsRing:"\n\n\n    uniform mat4 iModelMat;\n\n    attribute vec3 tangent;\n    attribute float faceType;\n    attribute float id;\n\n    // TODO: can we compute this in cpu?\n    varying mat3 vINormMat;\n\n    varying vec3 vNorm;\n    varying vec3 vTang;\n    varying vec3 vBino;\n    varying vec2 vUv;\n\n    varying vec3 vEye;\n    varying vec3 vMPos;\n    varying vec3 vPos;\n\n    varying float vType;\n    varying float vID;\n\n    mat3 matInverse( mat3 m ){\n    \n  \n    vec3 a = vec3(\n      \n        m[1][1] * m[2][2] - m[2][1] * m[1][2],\n        m[0][2] * m[2][1] - m[2][2] * m[0][1],\n        m[0][1] * m[1][2] - m[1][1] * m[0][2]\n        \n    );\n    \n    vec3 b = vec3(\n      \n        m[1][2] * m[2][0] - m[2][2] * m[1][0],\n        m[0][0] * m[2][2] - m[2][0] * m[0][2],\n        m[0][2] * m[1][0] - m[1][2] * m[0][0]\n        \n    );\n    \n     vec3 c = vec3(\n      \n        m[1][0] * m[2][1] - m[2][0] * m[1][1],\n        m[0][1] * m[2][0] - m[2][1] * m[0][0],\n        m[0][0] * m[1][1] - m[1][0] * m[0][1]\n        \n    );\n    \n    \n    return mat3( \n        \n       a.x , a.y , a.z ,\n       b.x , b.y , b.z ,\n       c.x , c.y , c.z\n        \n    );\n    \n \n  \n    \n}\n\n\n    void main(){\n\n      vType = faceType;\n\n      vec3 pos = position;\n      vUv = uv;\n      vNorm = normalMatrix * normal;\n      \n      vMPos = ( modelMatrix * vec4( pos , 1. ) ).xyz;\n      //vMPos = pos.xyz;\n\n      vNorm = normal;\n      vTang = tangent;\n\n      vBino = cross( vNorm , vTang );\n\n      mat3 normMat = mat3(\n        vNorm.x , vNorm.y , vNorm.z ,\n        vTang.x , vTang.y , vTang.z ,\n        vBino.x , vBino.y , vBino.z \n      );\n\n      //normMat = normalMatrix * normMat;\n      vINormMat = matInverse( normMat );\n      vID = id;\n\n      vec3 iCamPos = ( iModelMat * vec4( cameraPosition , 1. ) ).xyz;\n      vEye = iCamPos - pos;\n      vPos = pos;\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( pos , 1. );\n\n\n    }\n\n  ", fsRing:"\n\n   vec3 hsv(float h, float s, float v){\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n  }\n\n\n  // Taken from https://www.shadertoy.com/view/4ts3z2\n  float tri(in float x){return abs(fract(x)-.5);}\n  vec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                   \n\n  // Taken from https://www.shadertoy.com/view/4ts3z2\n  float triNoise3D(in vec3 p, in float spd , in float time){\n    \n    float z=1.4;\n    float rz = 0.;\n    vec3 bp = p;\n\n    for (float i=0.; i<=3.; i++ ){\n     \n      vec3 dg = tri3(bp*2.);\n      p += (dg+time*.1*spd);\n\n      bp *= 1.8;\n      z *= 1.5;\n      p *= 1.2; \n        \n      rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n      bp += 0.14;\n\n    }\n\n    return rz;\n\n  }\n\nuniform float stepDepth;\nuniform float oscillationSize;\nuniform float time;\nuniform float brightness;\nuniform float noiseSize;\nuniform vec3 lightPos;\nuniform float percentLoaded;\nuniform float transparency;\n\nvarying float vType;\nvarying float vID;\n\nvarying vec3 vNorm;\n\nvarying vec2 vUv;\n\nvarying vec3 vEye;\nvarying vec3 vMPos;\nvarying vec3 vPos;\n\n\n\nvarying mat3 vINormMat;\n\n#define STEPS 2\nvec4 volumeColor( vec3 ro , vec3 rd  , mat3 iBasis){\n\n  vec3 col = vec3( 0. );\n  float lum = 0.;\n  for( int i = 0; i < STEPS; i++ ){\n\n    vec3 p = ro - rd * float( i ) * stepDepth*5.;\n    \n    lum += pow(triNoise3D( p * .002 * noiseSize , float( i ) / float( STEPS ), time * .01),.3);//lu / 5.;\n\n    col +=  hsv( lum * 2. + sin( time * .1 ) ,  .4  , .5 );\n\n  } \n\n  return vec4( col , lum ) / float( STEPS );\n\n\n}\n\n\nvoid main(){\n\n\n  vec3 col =vec3(1.);// vTang * .5 + .5;\n  float alpha = 1.;\n\n  vec3 lightDir = normalize( lightPos - vMPos );\n  vec3 reflDir = reflect( lightDir , vNorm );\n  \n  float lambMatch =  -dot(lightDir ,  vNorm );\n  float reflMatch = max( 0. , -dot(normalize(reflDir) ,  normalize(vEye)) );\n\n  reflMatch = pow( reflMatch , 2. );\n\n  vec4 volCol = volumeColor( vPos , normalize(vEye) , vINormMat );\n\n  vec3 lambCol = lambMatch * volCol.xyz;\n  vec3 reflCol = reflMatch * (vec3(1.) - volCol.xyz);\n\n  col = volCol.xyz;// * lambMatch  + vec3(1. ) * (1.-lambMatch ) ;\n\n  float size = .04;\n  if( vUv.y > 1. - size  ){\n    col *= 2.;// lambCol * 3.;\n  }\n\n  if( vType > 0.5){\n    col *= sin( (( vID /80.) * 6. * 3.14195  )+ time * percentLoaded * 5.);\n  }else{\n    if( vUv.x < .1 || vUv.x > .9 || vUv.y < .2 || vUv.y > .8 ){\n    }else{\n      if( percentLoaded - .01 < vID / 40. ){\n        col = vec3( 0. );\n      }\n    }\n  }\n\n\n  gl_FragColor = vec4(  col *2. * brightness , transparency  );\n\n}\n\n\n  "}
